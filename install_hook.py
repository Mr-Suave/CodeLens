import os
import stat
import sys

HOOK_TEMPLATE = HOOK_TEMPLATE = """#!/bin/bash
# prepare-commit-msg hook generated by CodeLens
# Auto-generates commit message from comments using Gemini AI

CODELENS_TOOL="{main_script_path}"
COMMIT_MSG_FILE="$1"

# Call Python script and capture its output directly
COMMIT_MSG=$(python3 "$CODELENS_TOOL" --generate-only)

# Print to terminal
echo "Generated Commit Message:"
echo "$COMMIT_MSG"

# Write to the actual commit message file used by Git
echo "$COMMIT_MSG" > "$COMMIT_MSG_FILE"

"""


def install_hook():
    git_hook_path = os.path.join(".git", "hooks", "prepare-commit-msg-23-13")
    
    if not os.path.isdir(".git/hooks"):
        print(" Not a Git repository or missing .git/hooks directory.")
        sys.exit(1)

    tool_repo_root = os.path.abspath(os.path.dirname(__file__))
    main_script_path = os.path.join(tool_repo_root, "CodeLens", "commit_msg_generation.py")

    if not os.path.exists(main_script_path):
        print(f" Could not find commit_msg_generation.py at: {main_script_path}")
        sys.exit(1)

    with open(git_hook_path, "w") as hook_file:
        hook_file.write(HOOK_TEMPLATE.format(main_script_path=main_script_path))

    # Make the hook executable
    st = os.stat(git_hook_path)
    os.chmod(git_hook_path, st.st_mode | stat.S_IEXEC)

    print(f" Git hook installed at {git_hook_path}")
    print(" On next `git commit`, commit message will be generated by CodeLens.")

if __name__ == "__main__":
    install_hook()
